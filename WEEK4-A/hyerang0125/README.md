> 🖇2021 2학기 4주차 - 분할정복

</br>

# ✔ 분할정복

## 정의

- 문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병하여 문제의 답을 얻는 알고리즘

</br>

## 알고리즘을 설계하는 요령

1. Divide : 문제가 분할이 가능한 경우, 2개 이상의 문제로 나눈다.
2. Conquer : 나누어진 문제가 여전히 분할이 가능하면, 또 다시 Divide를 수행한다. 그렇지 않으면 문제를 푼다.
3. Combine : Conquer 한 문제들을 통합하여 원래 문제의 답을 얻는다.

</br>

# 1️⃣ Binary Search (이분 탐색)

## 이분탐색 알고리즘 (오름차순으로 정렬된 데이터를 기준으로 설명)

1. 배열의 가운데 원소와 탐색키를 비교한다.
2. 탐색키와 가운데 원소가 같다면 탐색에 성공한 것이다.
3. 탐색키의 값이 가운데 원소의 값보다 작다면, 배열 절반 중 왼쪽 부분 배열을 호출하여 이분 탐색을 진행한다.
4. 탐색 키의 값이 가운데 원소의 값보다 크다면, 배열 절반 중 오른쪽 부분 배열을 호출하여 이분 탐색을 진행한다.

## 이분탐색 특징

- 탐색을 반복할 때마다 대상 원소의 개수가 절반씩 감소한다.

## 이분탐색 시간복잡도

$$ O(log\,n) $$

</br>

# 2️⃣ Merge Sort (합병 정렬)

## 합병정렬 알고리즘

1. 정렬할 데이터 집합의 크기가 0 또는 1이면 이미 정렬된 것으로 본다.
2. 데이터 집합의 크기가 2 이상이면 데이터 집합을 반으로 나눈다.
3. 원래 같은 집합에서 나뉘어져 나온 데이터 집합 둘을 병합하여 하나의 데이터 집합으로 만든다. 단, 병합할 때 데이터 집합의 원소는 순서에 맞춰 정렬한다.
4. 데이터 집합이 다시 하나가 될 때까지 3번을 반복한다.

</br>

## 합병정렬 시간복잡도

$$ O(nlog\,n)$$

## 합병정렬 공간복잡도

$$ O(n) $$

</br>

# 3️⃣ Quick Sort (퀵 정렬)

- 특정 원소 pivot을 기준으로 주어진 배열을 두 부분 배열로 분할하고 각 부분배열에 대해 퀵 정렬을 순환적으로 적용하는 방식

## 퀵 정렬 알고리즘

- 분할 : pivot을 기준으로 배열을 두 부분 배열로 분할
- 정복 : 두 부분 배열에 대해 퀵 정렬을 순환적으로 적용하여 각 부분 배열을 정리
- 결합 : 결합 불필요

## 퀵 정렬 시간복잡도

- 분할 시간 + 순환 호출의 깊이로 이루어 진다.

- 평균

$$ O(nlon\,n) $$

- 최악

$$ O(n^2) $$

- 최선

$$ O(nlon\,n) $$

</br>

# 4️⃣ Exponentiation (거듭제곱)

- n 거듭 제곱은 자신을 n번 곱해야 한다.
- 그러나 분할정복을 응용하여 지수를 반으로 나눠가며 거듭 제곱을 수행하면 수행 시간을 줄일 수 있다.

</br>

$$ C^n = \begin{cases}
C^{(n-1)/2}C^{(n-1)/2}, \; if \; n = 홀수\\
C^{n/2} C^{n/2}, \; if \; n=짝수\\
\end{cases}$$

</br>

## 시간복잡도

$$ O(log\,n) $$

</br>

# 5️⃣ Fibonacci Sequence (피보나치 수열)

- 피보나치 수열은 다음과 같이 정의 된다.

$$ F_n = \begin{cases}
0, \; if \; n=0 \\
1, \; if \; n=1 \\
F_{n-1} + F_{n-2}, \; if \; n>1 \\
\end{cases}$$

- 이 알고리즘으로 걸리는 시간은 다음과 같다.

$$ O(2^n) $$

- 연산을 줄이기 위해 2차 정사각 행렬을 이용하면 다음과 같이 나타낼 수 있다.

$$\begin{bmatrix}
F_2 & F_1\\
F_1 & F_0\\
\end{bmatrix}
=
\begin{bmatrix}
1 & 1\\
1 & 0\\
\end{bmatrix}$$

- n 제곱을 하게 되면 아래와 같이 나타낼 수 있다.

$$\begin{bmatrix}
F_{n+1} & F_n\\
F_n & F_{n-1}\\
\end{bmatrix}
=
\begin{bmatrix}
1 & 1\\
1 & 0\\
\end{bmatrix}^n
=
\begin{bmatrix}
1 & 1\\
1 & 0\\
\end{bmatrix}^{n/2}
\begin{bmatrix}
1 & 1\\
1 & 0\\
\end{bmatrix}^{n/2}$$

- 이렇게 거듭제곱 알고리즘과 비슷하게 나타낼 수 있다.

## 피보나치 수열시간복잡도

$$ O(log\, n) $$
