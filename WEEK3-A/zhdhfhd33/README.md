# dfs - stack
stack을 이용한다. 재귀로도 구현가능. 아마 stack을 사용하는 것이 오버헤드가 더 적지 않을까 생각

# bfs - queue
queue를 이용한다. BBQ로 외웠음. queue에 넣기 전에 isVisited와 다른 조건들을 검사하고 방문할 가치가 있는 노드만 Queue에 넣고 방문처리까지 하는 것이 일반적이다. 
(방문처리는 queue.pop()한 뒤에 해도 크게 상관은 없읏듯.)
queue에서 원소를 꺼낸 다음에는 단순 종료조건이나 간단한 처리가 들어간다.

# 시간복잡도
dfs, bfs의 시간복잡도는 같다.
인접행렬로 구현 - O(V^2)
연결리스트로 구현 - O(V+E)

이는 꽤 차이가 많이 난다. 노드 하나당 edge를 n개씩 가지고 있을 때 비로소 O(V+E)=O(V^2)이 된다. 웬만한 상황에서는 연결리스트로 구현하는 것이 빠르다.

bfs는 찾고자 하는 노드를 찾으면 탐색한 경로가 최단거리이다. 하지만 dfs는 최단경로를 보장받지는 않는다. 일반적으로 bfs가 조금 더 성능이 좋다고 한다.

