## 재귀 함수
어떤 함수에서 자신을 다시 호출하여 작업을 수행하는 방식

```c++
void Binaryto(long long n) {
	if (n != 1) Binaryto(n / 2);
	cout << (n % 2);
}
```
#### 유의할 점
함수가 끝날 때 함수 호출 이후의 명령문이 수행되지 않음.<br>
종료 조건이 꼭 포함되어야 함<br>
#### 재귀함수의 단점
- 함수 호출 시 `함수의 매개 변수, 지역변수, 리턴값, 함수 종료 후 돌아가는 위치`가 스택 메모리에 저장
- 따라서, 메모리를 많이 차지 -> 성능이 반복문에 비해 느림.
- 함수를 반복적으로 호출하기 때문에 스택 메모리가 커지고, 호출하는 횟수가 많아지며 스택오버플로우가 발생할 수 있음.

## 정수를 문자열로, 문자열을 정수로
1. 정수->문자열(int to string) : to_string() 사용
2. 문자열->정수 : int로 변환 후 - 48

```c++
while (int(x.size()) != 1) {
		int sum = 0;
		for (unsigned i = 0; i < x.size(); i++) {
			sum += int(x[i]) - 48; 
		}
		x = to_string(sum);
		i++;
	}
```

## 분할정복
문제를 나눌 수 없을 때까지 나누어서 각각을 풀고, 다시 합쳐 문제의 답을 얻는 알고리즘 

### (1) 분할정복 알고리즘 설계
1. Divide(분할) : 문제가 분할 가능하다면, 2개 이상의 문제로 나눈다.
2. ConQuer(정복) : 나눈 문제가 또 분할 가능하다면, divide를 또 다시 수행한다. 그렇지 않다면 문제를 푼다.
3. Combine(결합) : Conquer한 문제를 합해 본래 문제의 답을 찾는다.
* 단점 : 함수를 재귀적으로 호출해야 하기 때문에 함수 호출로 인한 오버헤드가 발생하며, 스택에 다양한 데이터를 보관하고 있어야 하므로 스택오버플로우가 발생하거나 과도한 메모리를 사용한다.

### (2) 분할정복 응용
#### 병합정렬(Merge Sort) - 시간복잡도 O(nlogn), 공간복잡도 O(n)
1. 정렬할 데이터 집합 크기가 0또는1 이면 이미 정렬된 것으로 본다.
2. 1의 경우에 해당하지 않으면, 데이터 집합을 반으로 나눈다.
3. 원래 같은 집합에서 나뉘어져 나온 데이터 집합 둘을 병합하여 하나의 데이터 집합으로 만든다. 단, 병합할 때의 데이터 집합의 원소는 순서에 맞춰 정렬한다.
4. 데이터 집합이 하나가 될 때 까지 3의 과정을 반복한다.

#### 이진탐색 T(n) = logn
1. Divide(분할) : 배열의 가운데 원소를 기준으로 왼쪽, 오른쪽 부분배열로 분할. 탐색키와 가운데 원소가 같으면 반환 및 종료
2. ConQuer(정복) : 탐색 키가 가운데 원소보다 작으면 왼쪽 부분 배열을 대상으로 이진탐색을 순환 호출, 크면 오른쪽 부분배열을 대상으로 이진탐색을 순환 호출
3. Combine(결합) : 탐색 결과가 직접 반환 되기 때문에 결합 불필요

#### 퀵 정렬
1. Divide(분할) : 피벗을 기준으로 배열을 두 부분 배열로 분할
2. ConQuer(정복) : 두 부분배열에 대해 퀵 정렬을 순환적으로 적용하여 각 부분배열을 정렬
3. Combine(결합) : 결합 불필요

#### 거듭제곱
원래 거듭제곱은 자신을 n번 곱해야 하므로 O(n)의 시간이 소요된다.<br><br>

지수를 반으로 나눈 거듭 제곱 알고리즘의 수행시간 : O(log<sub>2</sub>n)
지수가 짝수일 경우 ) 지수를 반으로 나눠서 곱한다. C<sup>(n/2)</sup> * C<sup>(n/2)</sup> <br>
지수가 홀수일 경우 ) 지수에서 1을 빼고 반으로 나눠 곱하고, 밑을 한 번 더 곱한다. C<sup>(n-1)</sup>*C<sup>((n-1)/2)</sup>