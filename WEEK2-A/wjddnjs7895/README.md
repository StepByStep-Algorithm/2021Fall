# <목록>
1. 완전탐색(Bruteforce)
2. 백트랙킹(Backtracking)
3. DFS(Deep-First-Search)
4. 결론
<br>
<br>

##  1) 완전탐색(Bruteforce)
+ 특징
	+  **모든 경우의 수**를 확인해보는 방법
	+ 암호학등에서 가장 확실한 방법으로 알려진 방법
<br>

## 2) 백트랙킹(Backtracking)
```C++
int arr[100] = { 0, };
void recur(int n) {
	if (n == 100) return;
	for (int i = 1; i <= 3; i++) {
		arr[n] = i;
		recur(n+1);
		arr[n] = 0;
	}
}
```
+ 백트랙킹은 브루트포스 방법의 한 종류로 흔하게 **재귀**를 사용해 구현할 수 있다.
+ 이때 재귀에서 return 된 이후에는 변경되었던 사항들을 **다시 원상복귀해주는 부분**이 필수이다. 
+ 위 코드는 대충 recur 전후로 arr이라는 배열의 n인덱스에 들어있는 값을 변경해주는 점 코드를 써봤는데 사실 아무 의미 없는 코드이다.
+ 사실 이 부분을 강조하는 이유는 이번 주 과제였던 스도쿠 문제를 풀다가 백트랙킹이 오랜만이라서 저 부분을 빼먹고 시간을 날렸기 때문에 다시는 까먹자 말자는 저만의 다짐했기 때문입니다.


## 3) DFS(Deep-First-Search)
```C++
void dfs(int n) {
	visited[n] = 1;
	printf("%d ", n);
	for (int i = 0; i < arr[n].size(); i++) {
		if (!visited[arr[n][i]]) {
			dfs(arr[n][i]);
		}
	}
}
```

+ 위 코드는 boj 1260에서 가져온 dfs 함수입니다.
+ 가장 기본적인 **visited 배열**과 주어진 그래프의 간선들의 주어져있는 arr 배열을 이용해 구현한 함수입니다.
+ dfs는 bfs와 다르게 주로 **재귀**를 통해 이루어진다.

## 4) 결론
+ 브루트포스는 따로 공부하지 않아도 흔하게 생각할 수 있지만 dfs, bfs와 같은 알고리즘들은 트리와 같은 자료구조들을 함께 이용했을 때 강력해진다. 예를 들어 위 dfs 파트에서 주어졌던 코드의 원문인 boj1260에서는 해당 문제를 인접리스트로 풀이한 사람들이 많았다. 때문에 저런 대표적인 알고리즘들은 확실한 코드를 알아놓는 것이 중요할 것 같다.