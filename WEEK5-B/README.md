> # WEEK5-그래프
#### 1. 그래프 탐색
#### 2. 깊이 우선 탐색
#### 3. 너비 우선 탐색
</br>

# 1️⃣ 그래프 탐색
### 그래프
* G = (V, E)      // vertex, edge
* V는 vertex의 집합 (=node, point)
* E는 edge의 집합   (=arcs, lines)

  

# 2️⃣ 깊이 우선 탐색
* 현재 정점에서 갈 수 있는 점들까지 들어가면서 탐색
* 수직 방향으로 탐색함
* 스택 또는 재귀함수로 구현  

### 알고리즘
 1. 탐색 시작 노드를 스택에 삽입하고 방문처리 표시
 2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문처리
    방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냄
 3. 2번의 과정을 수행할 수 없을 때까지 반복함
 
### 장단점
* 장점
  - 현재 진행하고 있는 경로의 노드만을 기억하면 되므로 차지하는 저장공간이 비교적 작음
  - 목표노드가 깊은 단계에 있을 경우 해를 빨리 구할 수 있음
* 단점
  - 얻어진 해가 최단 경로가 된다는 보장이 없음. 이는 목표에 이르는 경로가 다수인 문제에 대해 DFS는 해에 다다르면 탐색을 끝내버리므로, 이때 얻어진 해는 최적이 아닐 수도 있음
  
### C++ 코드
```C++
void dfs(int x)
{
	visited[x] = true;
	cout << x << " ";
	for (int i = 0; i < graph[x].size(); i++)
	{
		int y = graph[x][i];
		if (!visited[y])
            dfs(y);
	}
}
```
# 3️⃣ 너비 우선 탐색
* 현재 정점에 연결된 가까운 점들부터 탐색
* 수평 방향으로 탐색함
* 큐를 이용해서 구현

### 알고리즘
1. 탐색 시작 노드를 큐에 삽입하고 방문처리 표시
2. 큐에서 노드를 꺼낸 뒤에 꺼내진 노드의 인접 노드 중 방문하지 않은 노드를 모두 큐에 삽입 후 방문 처리함
3. 2번 반복

### 장단점
* 장점
  - 출발노드에서 목표노드까지의 최단 길이 경로를 보장함
* 단점
  - 경로가 매우 길 경우에는 탐색 가지가 급격히 많아져 보다 많은 기억 공간을 필요로 함

### C++ 코드
```C++
// BFS 함수 정의
void bfs(int start) {
    queue<int> q;
    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int x = q.front();
        q.pop();
        cout << x << ' ';
        for (int i = 0; i < graph[x].size(); i++) {
            int y = graph[x][i];
            if (!visited[y]) {
                q.push(y);
                visited[y] = true;
            }
        }
    }
}
```
